import ij.*;
import ij.io.*;
import ij.process.*;
import ij.gui.*;
import ij.plugin.*;

import java.io.*;
import java.awt.*;
import java.util.StringTokenizer;
import java.text.DecimalFormat;

/***********************************************************************************************************************************
Name:		Stitch_BLISS
Description:	This plugin stitches the tile images generated by the BLISS system from Bacus Laboratories, Inc.
		<http://www.bacuslabs.com> into complete core images.  
Authors:		Andy Chan <achan@bcgsc.ca> and Dmitry Turbin, MD/PhD <NetsTurb5@netscape.net> at the Genetic
		Pathology Evaluation Centre <http://www.gpec.ubc.ca>
History:		2004/05/05:	Initial version.  Allows specification of an image folder to stitch from.  User can
				specify the number of tile rows and tile columns.	
************************************************************************************************************************************/

public class Stitch_BLISS implements PlugIn {
	public void run(String arg) {
		if (arg.equals("about")) {showAbout(); return;}

		String csv_file = "DB_Input.csv"; 
		String path;                           // Source path
		String stripped_path;          // Source path with the last backslash stripped
		String path_name;              // The name of the source directory
		String stitched_path;          // The output path for stitched images

		// Ask user to specify the location of the CSV file
		IJ.showMessage("Please specify the path to the " + csv_file + ".");		
		OpenDialog od = new OpenDialog("","",csv_file);
		path = od.getDirectory();
		stripped_path = path.substring(0, path.length() - 1);	
		File f = new File(stripped_path);
		path_name = f.getName();
		String source_csv_file = path + csv_file;		

		// Obtain and create the stitched path
		stitched_path = IJ.getString("Please specify the path for the output files: ", stripped_path + "_stitched\\");
		f = new File(stitched_path);
		f.mkdir();

		// Copy the DB_Input.csv file
		File source_file = new File(source_csv_file);
		File target_file = new File(stitched_path + csv_file);
		try {
			copy(source_file, target_file);
		}
		catch(IOException e) {
			IJ.showMessage("Cannot copy DB_Input.csv file.");
		}

		// Get number of tiles per row and column
		int tile_cols = Integer.parseInt(IJ.getString("Please specify the number of tile columns per core image: ", "3"));
		int tile_rows = Integer.parseInt(IJ.getString("Please specify the number of tile rows per core image: ", "3"));
		int tiles_per_core = tile_cols * tile_rows;

		int tile_width = 752; //Integer.parseInt(IJ.getString("Please specify the width of each tile: ", "752"));
		int tile_height = 480; //Integer.parseInt(IJ.getString("Please specify the height of each tile: ", "480"));

		// Figure out the image height and width
		int img_width = tile_width * tile_cols;
		int img_height = tile_height * tile_rows;

		//Read the CSV file
 		 try {
   			FileReader fr = new FileReader(source_csv_file);
   			BufferedReader bIn = new BufferedReader(fr);

  			 //read first line from file
  			String line;
			int line_index = 0;
			int core_img_index = 1;  // Index of core images
			int tile_index = 0;             // Index of tiles
			int img_count;  // Number of core images in the subfolder
			String core_img_index_format = "000"; // The string format of the image index
   			while ((line = bIn.readLine()) != null) {
				if (line_index == 0) { // First line - tells you number of cores
					img_count = Integer.parseInt(line);
				}
				else {
					// Get the row and column
					StringTokenizer st = new StringTokenizer(line);
         					int row = Integer.parseInt(st.nextToken(","));
					int col =  Integer.parseInt(st.nextToken(","));

					// Create new image
					DecimalFormat df = new DecimalFormat(core_img_index_format);
					String stitched_filename = path_name + "_" + df.format(core_img_index) + "_r" + row + "c" + col + ".jpg";
					ImagePlus stitched = NewImage.createRGBImage(stitched_filename, img_width, img_height, 1, NewImage.FILL_WHITE);
					ImageProcessor stitched_proc = stitched.getProcessor();
		
					for (int row_index = 1; row_index <= tile_rows; row_index++) {
						if ((row_index % 2) == 0) { // Even rows
							for (int col_index = tile_cols; col_index >= 1; col_index--) {
								stitched_proc = stitch(stitched_proc, tile_width, tile_height, col_index, row_index, path, tile_index);

								// Increment core image index
								tile_index++;
							}
						}
						else { // Odd rows
							for (int col_index = 1; col_index <= tile_cols; col_index++) {
								stitched_proc = stitch(stitched_proc, tile_width, tile_height, col_index, row_index, path,tile_index);

								// Increment tile index
								tile_index++;
							}
						}
					}

					// Save the image
					String target_img_file = stitched_path + stitched_filename;
					IJ.showStatus("Generating '" +stitched_filename +"'...");
					FileSaver fs = new FileSaver(stitched);
					fs.saveAsJpeg(target_img_file);

					// Increment core image index
					core_img_index++;
				}
				line_index++;
			}
		}
		catch(IOException e) {
			IJ.showMessage("File not found.");
		}

		IJ.showMessage("Done stitching images in '" + path + "'.");
	}

	// Open a single tile image and copy it
	private ImageProcessor stitch (ImageProcessor stitched_proc, int tile_width, int tile_height, int col_index, int row_index, String path, int tile_index) {
		String source_file = path + "Da" + Integer.toString(tile_index) + ".jpg";
		// Open the individual tiled file
		IJ.showStatus("Stitching '" +  "Da" + Integer.toString(tile_index) + ".jpg" +"'...");
		ImagePlus ip = new ImagePlus(source_file);
		ImageProcessor iproc = ip.getProcessor();
					
		// Copy 
		int start_x = (col_index - 1) * tile_width;
		int start_y = (row_index - 1) * tile_height;

		stitched_proc.copyBits(iproc,start_x,start_y,Blitter.COPY);

		return stitched_proc;
	}

	// Method for copying a single file
	private void copy(File source, File dest) throws IOException {  // From Chris Smith, MindIQ Corporation
    		final int BUFFER_SIZE = 32768;
    		InputStream in = new FileInputStream(source);
    		try {
        			OutputStream out = new FileOutputStream(dest);
       			 try {
            				byte[] buffer = new byte[BUFFER_SIZE];
            				int len;

            				while ((len = in.read(buffer)) > 0) {
                					out.write(buffer, 0, len);
            				}
        			}
       		 	finally { out.close(); }
    		}
    		finally { in.close(); }
	} 

	// Help and About information
	private void showAbout() {
		String msg = "This plugin stitches the tile images generated by the BLISS system from Bacus Laboratories, Inc.\n" +
		 	"<http://www.bacuslabs.com> into complete core images.\n \n" +
			"Written by Andy Chan <achan@bcgsc.ca> and Dmitry Turbin, MD/PhD <NetsTurb5@netscape.net>\n" +
			"at the Genetic Pathology Evaluation Centre <http://www.gpec.ubc.ca>.\n \n" +
			"Usage of the plugin:\n" + 
			"1) Run the Stitch_BLISS plugin.\n" + 
			"2) Select the 'DB_input.csv' file from a BLISS generated image folder.  The tile images inside this\n" +
			"folder will be stitched.\n" + 
			"3) Specify the output folder that will contain the stitched images.  By default the name of this folder\n" + 
			"will be the name of the source folder with '_stitched' appended to the end.  Note that this folder will\n" +
			"be generated automatically and the DB_input.csv file will be copied over to this folder as well.\n" +
			"4) Specify the number of tile columns and tile rows per image.  By default this is set to 3 x 3.\n" + 
			"5) The stitching process will start with the status bar showing the current tile image being stitched.\n" +
			"6) The user will be prompted once the stitching process is completed.";
		
		IJ.showMessage(msg);
	}
}
