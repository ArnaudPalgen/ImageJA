// Slow Fourier Transform
//-----------------------------------------------------
// "Brute Force" Fourier Transform
// Very naive implementation of usual DFTs,
// the slowest DFT you can find.
// Neither symmetry/parity/memoize nor "butterfly" trick,
// just raw and slow Discrete Fourier Transform.
// Unusable with large arrays!
// Actually, large is quite small :-)
// Direct+inverse transform took 13 sec for 800 pixels
// on a (old) Pentium4 1.6Ghz.


macro "LineFTTest" {
   if (selectionType != 5)
      exit("Line selection required!");
   x=getProfile();
   n=x.length;
   setBatchMode(true);
   T0=getTime();
   F=slowRFT1D(x);
   ift=slowIFT1D(F);
   T1=getTime();
   setBatchMode(false);
   name = "[SlowFT]";
   showStatus("Direct and inverse transform of "+n+" values took "+(T1-T0)/100+ "seconds");
   run("New... ", "name="+name+" type=Table");
   f = name;
   print(f,"\\Headings:x\tReF=Re(FT(x))\tImF=Im(FT(x))\tRe(IFT(F))\tIm(IFT(F)");
   for(i=0;i<n;i++)
      print(f,x[i]+"\t"+F[i]+"\t"+F[n+i]+"\t"+ift[i]+"\t"+ift[i+n]);
}
  


// direct real FT
function slowRFT1D(real_in) {
   N=real_in.length;
   S=newArray(2*N);
   showStatus("Direct real FT...");
   for (m=0; m<N; m++) {
      if (m%25==0) showProgress(m, N);
      RSm=0;
      ISm=0;
      for (k=0; k<N; k++) {
         RSm+=real_in[k]*cos(2*PI*k*m/N);
         ISm-=real_in[k]*sin(2*PI*k*m/N);
      }
      S[m]=RSm; //real part
      S[N+m]=ISm; //imaginary part
   }
   return S;
   //S:Complex: {Re[0],..Re[N-1],Im[0]..Im[N-1]}
}

//direct complex FT
function slowFT1D(z_in) {//z_in complex: {Re[0]..Re[N-1],Im[0]..Im[N-1]}
   N=z_in.length/2;
   S=newArray(2*N);
   for(m=0; m<N; m++) {
      RSm=0;
      ISm=0;
      for (k=0; k<N; k++) {
         c=cos(2*PI*k*m/N);
         s=-sin(2*PI*k*m/N);
         RSm+=(z_in[k]*c-s*z_in[k+N]);
         ISm+=(z_in[k]*s+c*z_in[k+N]);
      }
      S[m]=RSm;
      S[m+N]=ISm;
   }
   return S;
   // output= complex (as z_in...)
}

//Inverse complex FT
function slowIFT1D(S_in) { //S_in complex: {Re[0]..Re[N-1],Im[0]..Im[N-1]}
   N=S_in.length/2;
   sout=newArray(2*N);
   showStatus("Inverse complex FT...");
   for (k=0; k<N; k++) {
      if (k%25==0) showProgress(k, N);
      Rsk=0;
      Isk=0;
      for (m=0; m<N; m++) {
         c=cos(2*PI*k*m/N);
         s=sin(2*PI*k*m/N);
         Rsk += (S_in[m]*c-s*S_in[m+N]);
         Isk += (S_in[m]*s+c*S_in[m+N]);
      }
      sout[k] = Rsk/N;
      sout[N+k] = Isk/N;
   }
   return sout;
}

